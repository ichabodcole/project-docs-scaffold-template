# Documentation

This directory contains project documentation organized into focused
subdirectories. Each subdirectory serves a specific purpose in capturing
knowledge throughout the development lifecycle.

## Foundational Document

**[PROJECT_MANIFESTO.md](./PROJECT_MANIFESTO.md)** - The constitution of this
project. Defines what the project is, who it's for, core principles, what it
does and doesn't do. Read this first to understand the foundational vision and
boundaries.

## Structure

### `/reports`

Structured assessment and analysis reports that evaluate current state of code,
documentation, or systems. Reports are typically generated by automated
processes or AI agents and serve as discovery mechanisms that can trigger
investigations, proposals, or direct action. Examples: documentation status
reports, code reviews, security audits, performance analysis.

### `/investigations`

Research documents that explore questions before committing to proposals.
Investigations gather evidence, analyze options, and determine whether action is
warranted. Can be synthesized from patterns across multiple sessions or
triggered by findings in reports. Use these when you're uncertain if a proposal
is needed.

### `/proposals`

Feature proposals and design ideas that capture the _why_ and _what_ before
implementation begins. Proposals explore options, constraints, and expected
outcomes.

### `/plans`

Development plans that translate proposals into actionable paths forward. Plans
outline the _how_ with phased guidance, constraints, and acceptance criteria.
They bridge the gap between vision and execution.

### `/sessions`

Dev journals capturing what happened during implementation - what went smoothly,
what didn't, deviations from plan, and lessons learned. Focus on what stands
out, not routine work. Optional if nothing notable occurred; sessions should
feel worthwhile, not obligatory.

### `/playbooks`

Reusable dev plans for recurring tasks or augmenting existing systems (e.g.,
adding AI workflows, database entities). Playbooks codify proven approaches for
tasks you've done 2-3 times, including phases, pitfalls, and validation steps.

### `/architecture`

Maps of the landscape - what systems exist, where their boundaries are, and how
major pieces fit together. Focus on building mental models at high to mid-level;
avoid exhaustive detail that's better found by reading code.

### `/specifications`

Technology-agnostic specification documents that describe what the application
is, what it does, and how it behaves — organized by domain. Specifications are
portable: they contain no framework or library references and could be used to
rebuild the application in any technology stack. They serve as the living,
authoritative description of application behavior.

### `/interaction-design`

User experience flow documentation that captures how users interact with
features and subsystems. Documents user journeys, decision points, and design
rationale behind interaction patterns. Complements architecture docs by
explaining how features work from the user's perspective rather than the
technical perspective.

### `/lessons-learned`

Hard-won insights and non-obvious solutions discovered through experience.
Captures specific bugs/issues or code patterns ("don't do X, do Y") that aren't
easily Googled. These are the diamonds found through making mistakes.

### `/fragments`

Incomplete observations and "this doesn't feel quite right" moments that don't
fit into other document types. Fragments capture mysteries, workarounds, and
open questions without commitment to investigate. They're food for thought -
pieces that might become investigations, proposals, or lessons learned when you
have more context.

## Specifications: A Living Application Description

Specifications live outside the per-feature lifecycle below. They describe the
**whole application's behavior** in technology-agnostic terms — a living
document that answers "what does this application do?" independent of how it's
built.

Specifications can be **created before development begins** (defining what to
build from an idea) or **generated from an existing codebase**
(reverse-engineering a portable description). Either way, they should be
**updated as features are completed** to stay current.

While the flowchart below tracks individual features from idea to completion,
specifications track the cumulative state of the application itself. When you
finish building a feature, update the relevant specifications to reflect the new
behavior.

## Choosing the Right Document Type

Not sure which type of document to create? Use this decision flowchart:

```
                    START: What are you documenting?
                                  ↓
                    ┌─────────────────────────┐
                    │   Have a question or    │
                    │   uncertain if action   │
                    │   is needed?            │
                    └─────────────────────────┘
                              ↓
                    ┌─────────┴─────────┐
                    │   YES             │
                    └─────────┬─────────┘
                              ↓
                    Ready to investigate now?
                              ↓
                    ┌─────────┴─────────┐
                    │   YES             │   NO → FRAGMENT
                    └─────────┬─────────┘     (Capture for later)
                              ↓
                      INVESTIGATION
                  (lightweight-moderate)
                              ↓
                    ┌─────────────────────┐
                    │ Outcome determines  │
                    │ next step:          │
                    └─────────────────────┘
                              ↓
              ┌───────────────┴───────────────┐
              ↓                               ↓
      [Proposal Needed]            [No Action / Monitor]
              ↓                               ↓
          PROPOSAL                    Document decision
    (What should we build?)            (investigation
              ↓                         conclusion)
              ↓
    Is it approved/ready
    for implementation?
              ↓
          ┌───┴───┐
          │  YES  │
          └───┬───┘
              ↓
           PLAN
   (How will we build it?)
              ↓
      Currently working
      on implementation?
              ↓
          ┌───┴───┐
          │  YES  │
          └───┬───┘
              ↓
         SESSION
   (What happened today?)
              ↓
        Work complete?
              ↓
          ┌───┴───┐
          │  YES  │
          └───┬───┘
              ↓
      ┌───────────────────┐
      │ Documenting...    │
      └───────────────────┘
              ↓
    ┌─────────┴─────────────────────┐
    ↓                               ↓
[Pattern for                [System as-built]
 reuse]                              ↓
    ↓                    ┌───────────┴───────────┐
PLAYBOOK                 ↓                       ↓
                    ARCHITECTURE          INTERACTION DESIGN
                 (How does X work       (How does the user
                  technically?)          interact with X?)
```

**Quick Reference:**

- **Report:** "Here's what we found when assessing X." (retrospective,
  current-state)
- **Investigation:** "Should we even do this? Let me research..." (uncertain,
  exploratory)
- **Proposal:** "We should build X. Here's why and what." (committed idea)
- **Plan:** "Here's how we'll build X, step by step." (implementation roadmap)
- **Session:** "Here's what I did today while building X." (work log)
- **Playbook:** "Here's how to do X repeatedly." (reusable pattern)
- **Specification:** "Here's what the application does, described so anyone
  could rebuild it." (technology-agnostic behavior documentation)
- **Architecture:** "Here's how X works in our system." (technical as-built
  documentation)
- **Interaction Design:** "Here's how users interact with X and why." (UX flow
  as-built documentation)
- **Lesson Learned:** "We hit problem Y, here's the fix." (specific issue +
  solution)
- **Fragment:** "Something doesn't feel right about this solution" or "What if
  we tried X instead?" (incomplete observations)

**Special cases:**

- **Specific problem solved?** → Lesson Learned
- **Still figuring out the approach?** → Investigation first, then Proposal
- **Need a portable, technology-agnostic description of the application?** →
  Specification
- **Need to document an existing technical system?** → Architecture
- **Need to document how users interact with a feature?** → Interaction Design
- **Recurring task pattern?** → Playbook (after 2-3 implementations)
- **Something feels off or what if we did X instead, but can't investigate
  now?** → Fragment (revisit when you have more context)

## Usage

Each subdirectory contains its own README with detailed guidance on:

- When to create documents
- When NOT to create documents
- File naming conventions
- Recommended structure
- Tips and best practices

Refer to the subdirectory READMEs for specific instructions on creating and
maintaining documentation in each category.
